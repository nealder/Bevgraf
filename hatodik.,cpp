#include <GL/glut.h>
#include <math.h>
#include <iostream>
GLint keyStates[256];
#define PI 3.141592653589793
GLint winWidth = 800;
GLint winHeight = 600;

typedef struct point3dh { GLdouble x, y, z, h; } POINT3DH;
typedef struct point2d { GLdouble x, y; } POINT2D;
GLdouble eltol1[4][4];
GLdouble eltol2[4][4];
GLdouble forgaty1[4][4];
GLdouble forgaty2[4][4];
GLdouble forgaty3[4][4];
GLdouble forgatx[4][4];
GLdouble nagyit[4][4];
GLdouble kocka1[4][4];
GLdouble kocka2[4][4];
GLdouble kocka3[4][4];
GLdouble kocka4[4][4];
GLdouble kocka5[4][4];
GLdouble kocka6[4][4];
GLdouble temp1_1[4][4];
GLdouble temp1_2[4][4];
GLdouble temp2_1[4][4];
GLdouble temp2_2[4][4];
GLdouble temp3_1[4][4];
GLdouble temp3_2[4][4];
GLdouble temp4_1[4][4];
GLdouble temp4_2[4][4];
GLdouble temp5_1[4][4];
GLdouble temp5_2[4][4];
GLdouble temp6_1[4][4];
GLdouble temp6_2[4][4];
GLdouble VC[4][4];
GLdouble VM[4][4];
GLdouble WtV1[4][4];
GLdouble WtV2[4][4];
GLdouble s = 3;
POINT3DH Q[8];
POINT3DH W[8];
POINT3DH E[8];
POINT3DH A[8];
POINT3DH S[8];
POINT3DH D[8];
POINT3DH Qd[8];
POINT3DH Wd[8];
POINT3DH Ed[8];
POINT3DH Ad[8];
POINT3DH Sd[8];
POINT3DH Dd[8];
GLdouble szogx = 24 * 0.0174532925;
GLdouble szogy1 = 24 * 0.0174532925;
GLdouble szogy2 = 24 * 0.0174532925;
GLdouble szogy3 = 24 * 0.0174532925;
GLdouble delta = 5 * 0.0174532925; 

POINT3DH initPoint3dh(GLdouble x , GLdouble y , GLdouble z){
POINT3DH P;
P.x = x;
P.y = y;
P.z = z;
P.h = 1;
return P;
}

POINT2D initPoint2d(GLdouble x , GLdouble y){
POINT2D P;
P.x = x;
P.y = y;
return P;
}

POINT2D winMin = initPoint2d(-1, -1);
POINT2D winMax = initPoint2d(1, 1);
POINT2D viewMin1 = initPoint2d(0,100);
POINT2D viewMin2 = initPoint2d(400, 100);
POINT2D viewMax1 = initPoint2d(400, 500);
POINT2D viewMax2 = initPoint2d(800, 500);

void init( ) {
glClearColor( 1.0, 1.0, 1.0, 0.0 );
glMatrixMode( GL_PROJECTION );
gluOrtho2D( 0.0, winWidth, 0.0, winHeight );
glShadeModel( GL_FLAT );
glPointSize( 10.0 );
glLineWidth( 5.0 );
}

POINT3DH transzform(double matrix[][4], POINT3DH Q){
POINT3DH P;
P.x=matrix[0][0]*Q.x + matrix[0][1]*Q.y + matrix[0][2]*Q.z + matrix[0][3]*Q.h;
P.y=matrix[1][0]*Q.x + matrix[1][1]*Q.y + matrix[1][2]*Q.z + matrix[1][3]*Q.h;
P.z=matrix[2][0]*Q.x + matrix[2][1]*Q.y + matrix[2][2]*Q.z + matrix[2][3]*Q.h;
P.h=matrix[3][0]*Q.x + matrix[3][1]*Q.y + matrix[3][2]*Q.z + matrix[3][3]*Q.h;
return P;
}

void keyPressed (unsigned char key, int x, int y) {
keyStates[key] = 1;
}

void keyUp (unsigned char key, int x, int y) {
keyStates[key] = 0;
}

void keyOperations ( ) {
if(keyStates['q']){
	szogy3+=delta;
}
if(keyStates['w']){
	szogy3-=delta;
}
if(keyStates['a']){
	szogy2+=delta;
}
if(keyStates['s']){
	szogy2-=delta;
}
if(keyStates['y']){
	szogy1+=delta;
}
if(keyStates['x']){
	szogy1-=delta;
}

glutPostRedisplay( );
}

void mul_matrices( double A[ ][ 4 ], double B[ ][ 4 ], double C[ ][ 4 ] ){
int i, j, k;
float sum;
for( i = 0; i < 4; i++ ){
	for( j = 0; j < 4; j++ ){
		sum = 0;
		for( k = 0; k < 4; k++ ){
			sum = sum + A[ i ][ k ] * B[ k ][ j ];
		}
		C[ i ][ j ] = sum;
	}
}
}

void createFY1Matrix(GLdouble szog){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		forgaty1[i][j]=0;
	}
}
forgaty1[0][0]= cos(szog);
forgaty1[0][2]= sin(szog);
forgaty1[1][1]= 1;
forgaty1[2][0]= -sin(szog);
forgaty1[2][2]= cos(szog);
forgaty1[3][3]= 1;
}

void createFY2Matrix(GLdouble szog){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		forgaty2[i][j]=0;
	}
}
forgaty2[0][0]= cos(szog);
forgaty2[0][2]= sin(szog);
forgaty2[1][1]= 1;
forgaty2[2][0]= -sin(szog);
forgaty2[2][2]= cos(szog);
forgaty2[3][3]= 1;
}

void createFY3Matrix(GLdouble szog){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		forgaty3[i][j]=0;
	}
}
forgaty3[0][0]= cos(szog);
forgaty3[0][2]= sin(szog);
forgaty3[1][1]= 1;
forgaty3[2][0]= -sin(szog);
forgaty3[2][2]= cos(szog);
forgaty3[3][3]= 1;
}

void createFXMatrix(GLdouble szog){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		forgatx[i][j]=0;
	}
}
forgatx[0][0]= 1;
forgatx[1][1]= cos(szog);
forgatx[1][2]= -sin(szog);
forgatx[2][1]= sin(szog);
forgatx[2][2]= cos(szog);
forgatx[3][3]= 1;
}
/*
void createNMatrix(){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		nagyit[i][j]=0;
	}
}
nagyit[0][0]=150;
nagyit[1][1]=150;
nagyit[2][2]=150;
nagyit[3][3]=1;
}*/

void createWtVMatrix(POINT2D viewMin, POINT2D viewMax,POINT2D winMin,POINT2D winMax,GLdouble WtV[][4]){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		WtV[i][j]=0;
	}
}
WtV[0][0]=(viewMax.x-viewMin.x)/(winMax.x-winMin.x);
WtV[0][3]=viewMin.x-winMin.x*((viewMax.x-viewMin.x)/(winMax.x-winMin.x));
WtV[1][1]=(viewMax.y-viewMin.y)/(winMax.y-winMin.y);
WtV[1][3]=viewMin.y-winMin.y*((viewMax.y-viewMin.y)/(winMax.y-winMin.y));
WtV[2][2]=1;
WtV[3][3]=1;
}
/*
void createT1Matrix(GLdouble a, GLdouble b){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		eltol1[i][j]=0;
	}
}
eltol1[0][0]=1;
eltol1[1][1]=1;
eltol1[2][2]=1;
eltol1[3][3]=1;
eltol1[0][3]=a;
eltol1[1][3]=b;
}*/
/*
void createT2Matrix(GLdouble a, GLdouble b){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		eltol2[i][j]=0;
	}
}
eltol2[0][0]=1;
eltol2[1][1]=1;
eltol2[2][2]=1;
eltol2[3][3]=1;
eltol2[0][3]=a;
eltol2[1][3]=b;
}*/

void createVCMatrix(){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		VC[i][j]=0;
	}
}
VC[0][0]=1;
VC[1][1]=1;
VC[3][2]=-1/s;
VC[3][3]=1;
}

void createVMMatrix(){
for(int i = 0; i<4 ; i++){
	for(int j = 0; j<4 ; j++){
		VM[i][j]=0;
	}
}
VM[0][0]=1;
VM[1][1]=1;
VM[3][3]=1;
}

void Display(){

glClear(GL_COLOR_BUFFER_BIT);
glColor3f(1.0,0.0,0.0);

keyOperations();

createFY1Matrix(szogy1);
createFY2Matrix(szogy2);
createFY3Matrix(szogy3);

/*
mul_matrices(forgaty1,nagyit,kocka1);
mul_matrices(forgatx,kocka1,temp1_1);
mul_matrices(eltol1,temp1_1,temp1_2);
mul_matrices(VM,temp1_2,kocka1);

mul_matrices(forgaty2,nagyit,kocka2);
mul_matrices(forgatx,kocka2,temp2_1);
mul_matrices(eltol1,temp2_1,temp2_2);
mul_matrices(VM,temp2_2,kocka2);

mul_matrices(forgaty3,nagyit,kocka3);
mul_matrices(forgatx,kocka3,temp3_1);
mul_matrices(eltol1,temp3_1,temp3_2);
mul_matrices(VM,temp3_2,kocka3);

mul_matrices(forgaty1,nagyit,kocka4);
mul_matrices(forgatx,kocka4,temp4_1);
mul_matrices(eltol2,temp4_1,temp4_2);
mul_matrices(VM,temp4_2,kocka4);

mul_matrices(forgaty2,nagyit,kocka5);
mul_matrices(forgatx,kocka5,temp5_1);
mul_matrices(eltol2,temp5_1,temp5_2);
mul_matrices(VM,temp5_2,kocka5);

mul_matrices(forgaty3,nagyit,kocka6);
mul_matrices(forgatx,kocka6,temp6_1);
mul_matrices(eltol2,temp6_1,temp6_2);
mul_matrices(VM,temp6_2,kocka6);
*/

createWtVMatrix(viewMin1,viewMax1,winMin,winMax, WtV1);

mul_matrices(forgatx,forgaty1,temp1_1);
mul_matrices(VM,temp1_1,temp1_2);
mul_matrices(WtV1,temp1_2,kocka1);

mul_matrices(forgatx,forgaty2,temp2_1);
mul_matrices(VM,temp2_1,temp2_2);
mul_matrices(WtV1,temp2_2,kocka2);

mul_matrices(forgatx,forgaty3,temp3_1);
mul_matrices(VM,temp3_1,temp3_2);
mul_matrices(WtV1,temp3_2,kocka3);

createWtVMatrix(viewMin2,viewMax2,winMin,winMax, WtV2);

mul_matrices(forgatx,forgaty1,temp4_1);
mul_matrices(VC,temp4_1,temp4_2);
mul_matrices(WtV2,temp4_2,kocka4);

mul_matrices(forgatx,forgaty2,temp5_1);
mul_matrices(VC,temp5_1,temp5_2);
mul_matrices(WtV2,temp5_2,kocka5);

mul_matrices(forgatx,forgaty3,temp6_1);
mul_matrices(VC,temp6_1,temp6_2);
mul_matrices(WtV2,temp6_2,kocka6);

for(GLint i = 0 ; i < 8 ; i++){
	Qd[i] = transzform(kocka1,Q[i]);
	Wd[i] = transzform(kocka2,W[i]);
	Ed[i] = transzform(kocka3,E[i]);
	Ad[i] = transzform(kocka4,A[i]);
	Sd[i] = transzform(kocka5,S[i]);
	Dd[i] = transzform(kocka6,D[i]);
}

glBegin(GL_LINES);
glVertex2d(Qd[0].x/Qd[0].h,Qd[0].y/Qd[0].h);
glVertex2d(Qd[1].x/Qd[1].h,Qd[1].y/Qd[1].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[0].x/Qd[0].h,Qd[0].y/Qd[0].h);
glVertex2d(Qd[4].x/Qd[4].h,Qd[4].y/Qd[4].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[0].x/Qd[0].h,Qd[0].y/Qd[0].h);
glVertex2d(Qd[3].x/Qd[3].h,Qd[3].y/Qd[3].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[1].x/Qd[1].h,Qd[1].y/Qd[1].h);
glVertex2d(Qd[2].x/Qd[2].h,Qd[2].y/Qd[2].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[1].x/Qd[1].h,Qd[1].y/Qd[1].h);
glVertex2d(Qd[5].x/Qd[5].h,Qd[5].y/Qd[5].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[2].x/Qd[2].h,Qd[2].y/Qd[2].h);
glVertex2d(Qd[3].x/Qd[3].h,Qd[3].y/Qd[3].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[2].x/Qd[2].h,Qd[2].y/Qd[2].h);
glVertex2d(Qd[6].x/Qd[6].h,Qd[6].y/Qd[6].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[3].x/Qd[3].h,Qd[3].y/Qd[3].h);
glVertex2d(Qd[7].x/Qd[7].h,Qd[7].y/Qd[7].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[6].x/Qd[6].h,Qd[6].y/Qd[6].h);
glVertex2d(Qd[7].x/Qd[7].h,Qd[7].y/Qd[7].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[4].x/Qd[4].h,Qd[4].y/Qd[4].h);
glVertex2d(Qd[7].x/Qd[7].h,Qd[7].y/Qd[7].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[4].x/Qd[4].h,Qd[4].y/Qd[4].h);
glVertex2d(Qd[5].x/Qd[5].h,Qd[5].y/Qd[5].h);
glEnd();

glBegin(GL_LINES);
glVertex2d(Qd[6].x/Qd[6].h,Qd[6].y/Qd[6].h);
glVertex2d(Qd[5].x/Qd[5].h,Qd[5].y/Qd[5].h);
glEnd();

glutPostRedisplay();
glutSwapBuffers();
}

int main (int argc, char** argv) {

createVMMatrix();
createVCMatrix();
//createT1Matrix(522,300);
//createT2Matrix(266,300);
//createNMatrix();
createFXMatrix(szogx);	

glutInit (&argc, argv);
glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
glutInitWindowPosition (500, 100);
glutInitWindowSize (800, 600);
glutCreateWindow ("otodik");
init ( );
glutDisplayFunc (Display);
glutKeyboardFunc(keyPressed);
glutKeyboardUpFunc(keyUp);
glutMainLoop ( );
return 0;
}